* TODO
- [ ] SIMD
- [X] полное и занковое(или как это по-русски называется) умножение
  решил, что не нужно
- [ ] деление со знаком
- [X] stou, loau
  - [X] инструкции для переноса значений из user r.f. в kernel r.f. и наоборот
  - [X] нужны ли тогда stou и loau?
- [ ] понять, нужны ли прерывания в kernel mode
  да, нужны, так как подтверждение чтения и записи я собираюсь делать через прерывания, а ядру при инициализации нужно читать таблицу разделов на диске
  но в таком случае нужно как-то делать возврат из прерывания в kernel mode, что можно сделать через сохранение pc в стек, но именно этого я пытался избежать используя два регистровых файла
  как вариант, можно сохранать pc в стек только в том случае, если флаг USERMODE выключен
- [ ] при чтении 8 битного отриц. числа в 64 битное надо сохранить знак
  а зачем, если загружать два 8-и битных числа, например перемножать их, и сохранать результат опять в 8 бит, то нам совершенно безразницы, что просходит битах старше 8
  вопрос только в делении
- [X] MMIO
- [X] аппаратные прерываня
- [ ] виртуальная память
- [ ] syscall
- [ ] рассмотреть возможность перехода на размер маш. слова в 12 байт с выравниванием в 4 байта

* Регистры

Регистровый файл имеет интерестую особенность: он умеет в двойное продолжительное чтение.
То есть можно одновременно считывать два регистра(или один и тот же, но зачем) и параллельно чтению
производить запись. При этом запись в регистр, который сейчас читается, никак не скажется на выходе.
Это позволяет очень сильно упростить реализацию микрокодов.

всего есть 18 регистров:
  * 0 - всегда 0
  * 1..14 - регистры общего назначения
  * 15 - указатель на текущую инструкцию
  * 16 - указатель на таблицу виртуальных адресов(см. ниже)
  * 17 - регистр флагов

К 16 и 17 регистру обращение происходит через специальные инструкции.
  
все эти регистры содержатся в 2 экземлярах: для kernel mode и user mode

за переключение между этими режимами отвечает флаг в регистре состояний ядра(см. ниже)

** Состояния ядра

| № бита | Имя         | Значение                                                                               |
|--------+-------------+----------------------------------------------------------------------------------------|
|      0 | ENABLED     |                                                                                        |
|      1 | INTERRUPTS  |                                                                                        |
|      2 | PAGING      |                                                                                        |
|      3 | USER MODE   |                                                                                        |
|      4 | ISINTERRUPT | включается автоматически. если 1, то USER MODE = 0 и остальные прерывания не вызваются |


* Ядро
** Шины
- sdb (shared data bus)
- ab (address bus)
- Rout1 (reg. file output 1)
- Rout2 (reg. file output 2)

** Микрокоды

как работают матем. инструкции:
1) считать r2
2) считать r3
3) обработать их(+,-,*,/,&...)
4) sdb -> r1

как работают матем. инструкции:
1) считать r2
2) считать num64
3) обработать их(+,-,*,/,&...)
4) sdb -> r1

как работает addz:
1) is_zero
2) считать r2
3) считать num64
4) обработать их(+,-,*,/,&...)
5) sdb -> r1

как работает addc:
1) is_carry
2) считать r2
3) считать num64
4) обработать их(+,-,*,/,&...)
5) sdb -> r1

как работает adds:
1) is_sign
2) считать r2
3) считать num64
4) обработать их(+,-,*,/,&...)
5) sdb -> r1

как работают инстр. для записи:
1) считать r2
2) считать num64
3) сложить их
4) sdb -> ab
5) сброс шин(кроме ab)
6) считать r3 -> sdb
7) запись

как работают инстр. для чтения:
1) считать r2
2) считать num64
3) сложить их
4) sdb -> ab
5) сброс шин(кроме ab)
6) чтение
7) sdb -> r1

push:
1) считать sp
2) сложить с 0(или я сделаю перенос с r1 в sdb)
3) sdb -> ab(или я сделаю r1 -> ab)
4) сброс шин(кроме ab)
5) считать r3 -> sdb
6) запись
7) уменьшение sp

pop:
1) считать sp
2) сложить с 0(или я сделаю перенос с r1 в sdb)
3) sdb -> ab(или я сделаю r1 -> ab)
4) сброс шин(кроме ab)
5) чтение
6) sdb -> r1
7) увеличение sp

call:
1) считать sp
2) сложить с 0(или я сделаю перенос с r1 в sdb)
3) sdb -> ab(или я сделаю r1 -> ab)
4) сброс шин(кроме ab)
5) считать pc -> sdb
6) запись
7) увеличение sp
8) r3 -> pc

int:
1) num8 -> core_int

iret:
1) ISINTERRUPT off

chst:
1) проверка USERMODE
2) считать r2
3) сложить с 0(или я сделаю перенос с r1 в sdb)
4) sdb -> state

lost:
1) проверка USERMODE
2) state -> sdb
3) sdb -> r1

chtp:
1) проверка USERMODE
2) считать r2
3) сложить с 0(или я сделаю перенос с r1 в sdb)
4) sdb -> tp

lotp:
1) проверка USERMODE
2) tp -> sdb
3) sdb -> r1

chflag:
1) проверка USERMODE
2) считать r2
3) сложить с 0(или я сделаю перенос с r1 в sdb)
4) sdb -> flag

loflag:
1) проверка USERMODE
2) flag -> sdb
3) sdb -> r1

utok:
1) проверка USERMODE
2) считать r3_u -> sdb
3) sdb -> r1

ktou:
1) проверка USERMODE
2) считать r3 -> sdb
3) sdb -> r1_u

| Имя              | Описание            |
|------------------+---------------------|
| inter_off        | ISINTERRUPT off     |
| num8_to_core_int | core_int(num8)      |
| pc_to_sdb        | pc -> sdb           |
| r3_to_pc         | r3 -> pc            |
| sdb_to_ab        | sdb -> ab           |
| sdb_to_flag      | sdb -> flag         |
| sdb_to_r1        | sdb -> r1           |
| sdb_to_r1_u      | sdb -> r1_u         |
| sdb_to_state     | sdb -> state        |
| sdb_to_tp        | sdb -> tp           |
| state_to_sdb     | state -> sdb        |
| tp_to_sdb        | tp -> sdb           |
| flag_to_sdb      | flag -> sdb         |
| write            | запись              |
| read             | чтение              |
| is_usermode      | проверка USERMODE   |
| is_zero          |                     |
| is_carry         |                     |
| is_sign          |                     |
| bus_reset        | сброс шин(кроме ab) |
| read_num64       | считать num64       |
| read_r2          | считать r2          |
| read_r3          | считать r3          |
| r3_to_sdb        | считать r3 -> sdb   |
| r3_u_to_sdb      | считать r3_u -> sdb |
| read_sp          | считать sp          |
| inc_sp           | увеличение sp       |
| dec_sp           | уменьшение sp       |
| ALU_sum          | +                   |
| ALU_sub          | -                   |
| ...              |                     |

** Инструкции
структура инструкции:
  * 0..7 - opcode
  * 8..11 - register 1
  * 12..15 - register 2
  * 16..19 - register 3
  * 20..27 - num8
  * 28..29 - bitwidth

  * 0..63 - num64

|  № | Имя    | Аргументы | Описание                                      |
|----+--------+-----------+-----------------------------------------------|
|  0 | sto    | r r num64 |                                               |
|  1 | loa    | r r num64 |                                               |
|  2 | add    | r r r     |                                               |
|  3 | sub    | r r r     |                                               |
|  4 | mul    | r r r     |                                               |
|  5 | div    | r r r     |                                               |
|  6 | add    | r r num64 |                                               |
|  7 | sub    | r r num64 |                                               |
|  8 | mul    | r r num64 |                                               |
|  9 | div    | r r num64 |                                               |
| 10 | addz   | r r num64 |                                               |
| 11 | addc   | r r num64 |                                               |
| 12 | adds   | r r num64 |                                               |
| 13 | not    | r r       |                                               |
| 14 | and    | r r r     |                                               |
| 15 | or     | r r r     |                                               |
| 16 | xor    | r r r     |                                               |
| 17 | shl    | r r r     |                                               |
| 18 | shr    | r r r     |                                               |
| 19 | and    | r r num64 |                                               |
| 20 | or     | r r num64 |                                               |
| 21 | xor    | r r num64 |                                               |
| 22 | shl    | r r num64 |                                               |
| 23 | shr    | r r num64 |                                               |
| 24 | push   | r         |                                               |
| 25 | pop    | r         |                                               |
| 26 | call   | r         |                                               |
| 27 | int    | num8      |                                               |
| 28 | iret   |           |                                               |
| 29 | chst   | r         |                                               |
| 30 | lost   | r         |                                               |
| 31 | chtp   | r         |                                               |
| 32 | lotp   | r         |                                               |
| 33 | chflag | r         |                                               |
| 34 | loflag | r         |                                               |
| 35 | utok   | r r       | переносит r3 из user r.f. в r1 из kernel r.f. |
| 36 | ktou   | r r       |                                               |
#+TBLFM: $1=@#-2
#+TBLFM: $1='(format "%x" $1)


* Прерывания
выполнение прерывания включает флаг ISINTERRUPT, который переключает ядро в KERNELMODE

из програмных прерываний я вижу смысл только в двух:
  * syscall(отдельная инструкция, адрес обработчика хранится в ядре)
  * переключение контекста(вызывается другим ядром, которое обрабатывает прерывание от таймера)

остальные прерывания вызываются аппаратно, поэтому далее речь будет иммено про них

На каком ядре будет вызвано прерывание решает APIC на процессоре(у него есть таблица, которую можно менять)
Внутри ядра прерывания вызываются поочереди, прерывать прерывание нельзя.

(Интерестный вопрос: если прерываня на ядре выключены, но какое-нибудь устройство его отправило, то прерыване просто игнорировать или куда-нибудь сохранять?)
